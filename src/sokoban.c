/* SOKOBAN */

enum
{
	S_EMPTY          = 0,
	S_GOAL           = 1,
	S_PLAYER         = 2,
	S_PLAYER_ON_GOAL = 3,
	S_BOX            = 4,
	S_BOX_ON_GOAL    = 5,
	S_WALL           = 7
};

typedef struct
{
	uint8_t x, y;
} Position;

static Position position_next(Position pos, uint8_t key)
{
	switch(key)
	{
	case KEY_DOWN_PRESSED:  { Position a = { pos.x,     pos.y + 1 }; return a; }
	case KEY_UP_PRESSED:    { Position a = { pos.x,     pos.y - 1 }; return a; }
	case KEY_LEFT_PRESSED:  { Position a = { pos.x - 1, pos.y     }; return a; }
	case KEY_RIGHT_PRESSED: { Position a = { pos.x + 1, pos.y     }; return a; }
	}

	return pos;
}

#define SOKOBAN_LVL_COUNT 7
#define LEVEL_SIZE_BYTES  40

const uint8_t sokoban_levels[] PROGMEM =
{
	0x01, 0x01, 0xff, 0xfe, 0x00, 0x03, 0x88, 0x78, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x03, 0xff, 0xf0, 0x00, 0x03, 0x83, 0xc0, 0x00, 0x0e, 0x07, 0xfc, 0x00, 0x3d, 0x00, 0x70, 0x00, 0xe0, 0x41, 0xc0, 0x03, 0x81, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x02, 0xff, 0xff, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0e, 0x38, 0x1c, 0x00, 0x38, 0x94, 0x70, 0x00, 0xe0, 0xd1, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x04, 0x03, 0xff, 0xc0, 0x03, 0xfe, 0x07, 0xff, 0x8e, 0x00, 0x02, 0x0e, 0x38, 0xe0, 0x78, 0x38, 0xe0, 0x83, 0xc0, 0xe3, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x02, 0xff, 0xff, 0xff, 0x03, 0x80, 0x00, 0x1c, 0x0e, 0x0d, 0xb0, 0x70, 0x38, 0x00, 0x01, 0xc0, 0xff, 0xfe, 0x07, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x03, 0x1f, 0xff, 0xff, 0x00, 0x70, 0x00, 0x1c, 0x01, 0xc1, 0x84, 0x70, 0x3f, 0x10, 0x41, 0xc0, 0xe0, 0x18, 0x47, 0x03, 0x80, 0x00, 0x1c, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x01, 0xff, 0xfe, 0x00, 0x03, 0x80, 0x38, 0x00, 0x0e, 0x49, 0xe0, 0x00, 0x3c, 0x93, 0xf0, 0x00, 0xe0, 0x01, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t cur_byte, bit, byte;
static Position player;

static uint8_t sokoban_next_bit(const uint8_t *input)
{
	uint8_t v = (cur_byte & 0x80) ? 1 : 0;

	cur_byte <<= 1;
	--bit;
	if(bit == 0)
	{
		bit = 8;
		++byte;
		cur_byte = pgm_read_byte(input + byte);
	}

	return v;
}

static uint8_t sokoban_next_3(const uint8_t *input)
{
	uint8_t v = sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	return v;
}

static uint8_t sokoban_draw(uint8_t *level)
{
	uint8_t win = 1;
	led_clear_black();
	field_set(level, player.x, player.y, field_get(level, player.x, player.y) | S_PLAYER);
	for(uint8_t y = 0; y < LED_HEIGHT; ++y)
	{
		for(uint8_t x = 0; x < LED_WIDTH; ++x)
		{
			uint8_t tile = field_get(level, x, y);

			if(tile == S_BOX)
			{
				win = 0;
			}

			set_bits_color(tile);
			led_set_pixel(x, y);
		}
	}

	field_set(level, player.x, player.y, field_get(level, player.x, player.y) & ~S_PLAYER);
	led_update();

	return win;
}

static void sokoban_load_level(uint8_t *level, const uint8_t *input)
{
	bit = 8;
	byte = 0;
	player.x = pgm_read_byte(input + byte);
	++byte;
	player.y = pgm_read_byte(input + byte);
	++byte;
	cur_byte = pgm_read_byte(input + byte);

	for(uint8_t i = 0; i < LED_PIXELS; ++i)
	{
		level[i] = sokoban_next_3(input);
	}

	sokoban_draw(level);
}

static uint8_t shift_box(uint8_t *level, Position a, Position b, uint8_t prev)
{
	uint8_t bt = field_get(level, b.x, b.y);
	if(bt != S_EMPTY && bt != S_GOAL)
	{
		return 0;
	}

	field_set(level, a.x, a.y, prev);
	field_set(level, b.x, b.y, bt | S_BOX);
	return 1;
}

static uint8_t sokoban_move(uint8_t *level, uint8_t key)
{
	Position a = position_next(player, key);
	Position b = position_next(a, key);
	uint8_t at = field_get(level, a.x, a.y);

	switch(at)
	{
	case S_EMPTY:
	case S_GOAL:
		break;

	case S_BOX:
		if(!shift_box(level, a, b, S_EMPTY))
		{
			return 0;
		}
		break;

	case S_BOX_ON_GOAL:
		if(!shift_box(level, a, b, S_GOAL))
		{
			return 0;
		}
		break;

	default:
		return 0;
	}

	player = a;
	return sokoban_draw(level);
}

static void sokoban(void)
{
	uint8_t level[LED_PIXELS];
	uint8_t cur_level = 0;
	const uint8_t *level_offset = sokoban_levels;

	sokoban_load_level(level, level_offset);
	for(;;)
	{
		uint8_t key;
		while((key = key_get()))
		{
			switch(key)
			{
			case KEY_ESCAPE_PRESSED:
				return;

			case KEY_RIGHT_PRESSED:
			case KEY_LEFT_PRESSED:
			case KEY_UP_PRESSED:
			case KEY_DOWN_PRESSED:
				if(sokoban_move(level, key))
				{
					if(cur_level >= SOKOBAN_LVL_COUNT)
					{
						youwin();
						return;
					}

					++cur_level;
					level_offset += LEVEL_SIZE_BYTES;
					sokoban_load_level(level, level_offset);
				}
				break;
			}
		}
	}
}
