/* SOKOBAN */

/*

Bit mapping:

000 => Empty                    |   0,   0,   0
001 => Player starting position |   0, 255,   0
010 => Wall                     | 255, 255, 255
011 => Goal                     |   0,   0, 255
100 => Box                      | 255,   0    0
101 => Player on goal           |   0, 255, 255
110 => Box on Goal              | 255,   0, 255
111 => Unassigned

*/

enum
{
	S_EMPTY,
	S_PLAYER,
	S_WALL,
	S_GOAL,
	S_BOX,
	S_PLAYER_ON_GOAL,
	S_BOX_ON_GOAL
};

static uint8_t sokoban_colors[] PROGMEM =
{
	  0,   0,   0, /* 000 => Empty                    */
	  0, 255,   0, /* 001 => Player starting position */
	255, 255, 255, /* 010 => Wall                     */
	  0,   0, 255, /* 011 => Goal                     */
	255,   0    0, /* 100 => Box                      */
	  0, 255, 255, /* 101 => Player on goal           */
	255,   0, 255, /* 110 => Box on Goal              */
};

typedef struct
{
	uint8_t x, y;
} Position;

static Position position_next(Position pos, uint8_t key)
{
	switch(key)
	{
	case KEY_DOWN_PRESSED:  return { pos.x,     pos.y + 1 };
	case KEY_UP_PRESSED:    return { pos.x,     pos.y - 1 };
	case KEY_LEFT_PRESSED:  return { pos.x - 1, pos.y     };
	case KEY_RIGHT_PRESSED: return { pos.x + 1, pos.y     };
	}

	return pos;
}

const uint8_t sokoban_levels[] PROGMEM =
{
	0x49, 0x24, 0x00, 0x01, 0x18, 0xd0, 0x00, 0x04, 0x92, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x20, 0x00, 0x01, 0x06, 0x80, 0x00, 0x04, 0x02, 0x48, 0x00, 0x16, 0x20, 0x20, 0x00, 0x40, 0x40, 0x80, 0x01, 0x00, 0x92, 0x00, 0x04, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x24, 0x80, 0x01, 0x00, 0x02, 0x00, 0x04, 0x11, 0x08, 0x00, 0x10, 0x98, 0x20, 0x00, 0x41, 0xe0, 0x80, 0x01, 0x00, 0x02, 0x00, 0x04, 0x92, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x24, 0x80, 0x01, 0x24, 0x02, 0x49, 0x04, 0x00, 0x02, 0x04, 0x10, 0x40, 0x28, 0x10, 0x41, 0x86, 0x88, 0x41, 0x24, 0x92, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x24, 0x92, 0x01, 0x00, 0x00, 0x08, 0x04, 0x1e, 0xd0, 0xa0, 0x10, 0x00, 0x00, 0x80, 0x49, 0x24, 0x02, 0x00, 0x00, 0x12, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x24, 0x92, 0x00, 0x20, 0x00, 0x08, 0x00, 0x83, 0x8c, 0x20, 0x12, 0x10, 0xc0, 0x80, 0x40, 0x38, 0xc2, 0x01, 0x00, 0x00, 0x08, 0x04, 0x92, 0x49, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x24, 0x00, 0x01, 0x02, 0x10, 0x00, 0x04, 0xdb, 0x40, 0x00, 0x14, 0x91, 0x20, 0x00, 0x40, 0x00, 0x80, 0x01, 0x00, 0x02, 0x00, 0x04, 0x92, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t cur_byte, bit, byte;

static uint8_t sokoban_next_bit(uint8_t *input)
{
	uint8_t v = (cur_byte & 0x80) ? 1 : 0;

	cur_byte <<= 1;
	--bit;
	if(bit == 0)
	{
		bit = 7;
		++byte;
		cur_byte = pgm_read_byte(input + byte);
	}

	return v;
}

static uint8_t sokoban_next_3(uint8_t *input)
{
	uint8_t v = sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	return v;
}

static void sokoban_load_level(uint8_t *level, const uint8_t *input)
{
	bit = 7;
	byte = 0;
	cur_byte = pgm_read_byte(input);

	for(uint8_t i = 0; i < LED_PIXELS; ++i)
	{
		level[i] = sokoban_next_3(input);
	}
}

static uint8_t sokoban_win(void)
{
	for(uint8_t y = 0; y < LED_HEIGHT; ++y)
	{
		for(uint8_t x = 0; x < LED_WIDTH; ++x)
		{
			if(field_get(level, x, y) == S_BOX)
			{
				return 0;
			}
		}
	}

	return 1;
}

static void sokoban_draw(void)
{
	led_clear_black();
	for(uint8_t y = 0; y < LED_HEIGHT; ++y)
	{
		for(uint8_t x = 0; x < LED_WIDTH; ++x)
		{
			minesweeper_set_color(field_get(field, x, y));
			led_set_pixel(x, y);
		}
	}

	led_update();
}

static uint8_t sokoban_move(uint8_t key)
{
	Position a = position_next(player, key);
	Position b = position_next(a, key);
	uint8_t at = field_get(level, a.x, a.y);

	switch(at)
	{
	case S_EMPTY:
	case S_GOAL:
		break;

	case S_BOX:
		{
			uint8_t bt = field_get(level, b.x, b.y);
			if(bt != S_EMPTY && bt != S_GOAL)
			{
				return 0;
			}

			field_set(level, a.x, a.y, S_EMPTY);
			field_set(level, b.x, b.y, bt == S_GOAL ? S_BOX_ON_GOAL : S_BOX);
		}
		break;

	case S_BOX_ON_GOAL:
		{
			uint8_t bt = field_get(level, b.x, b.y);
			if(bt != S_EMPTY && bt != S_GOAL)
			{
				return 0;
			}

			field_set(level, a.x, a.y, S_GOAL);
			field_set(level, b.x, b.y, bt == S_GOAL ? S_BOX_ON_GOAL : S_BOX);
		}
		break;

	default:
		return 0;
	}

	player = a;
	return 1;
}

static void sokoban(void)
{
	uint8_t level[LED_PIXELS];
	uint8_t cur_level = 0;
	uint8_t x = 0;
	uint8_t y = 0;

	sokoban_load_level(level, sokoban_levels);
	for(;;)
	{
		uint8_t key;
		while((key = key_get()))
		{
			switch(key)
			{
			case KEY_ESCAPE_PRESSED:
				return;

			case KEY_CENTER_PRESSED:

				break;

			case KEY_DOWN_PRESSED:

				break;

			case KEY_UP_PRESSED:

				break;

			case KEY_LEFT_PRESSED:

				break;

			case KEY_RIGHT_PRESSED:

				break;
			}
		}
		switch()
		{
		case :
			youwin();
			return;
		}
	}
}
