/* SOKOBAN */

enum
{
	S_EMPTY          = 0,
	S_GOAL           = 1,
	S_PLAYER_ON_GOAL = 2,
	S_PLAYER         = 3,
	S_BOX            = 4,
	S_BOX_ON_GOAL    = 5,
	S_WALL           = 7
};

typedef struct
{
	uint8_t x, y;
} Position;

static Position position_next(Position pos, uint8_t key)
{
	/*switch(key)
	{
	case KEY_DOWN_PRESSED:  return { pos.x,     pos.y + 1 };
	case KEY_UP_PRESSED:    return { pos.x,     pos.y - 1 };
	case KEY_LEFT_PRESSED:  return { pos.x - 1, pos.y     };
	case KEY_RIGHT_PRESSED: return { pos.x + 1, pos.y     };
	}*/

	return pos;
}

const uint8_t sokoban_levels[] PROGMEM =
{
	//0xff, 0xfe, 0x00, 0x03, 0xa8, 0x78, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xf0, 0x00, 0x03, 0x83, 0xc0, 0x00, 0x0e, 0x07, 0xfc, 0x00, 0x3d, 0x40, 0x70, 0x00, 0xe0, 0x41, 0xc0, 0x03, 0x81, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0xff, 0xff, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0e, 0x3a, 0x1c, 0x00, 0x38, 0x94, 0x70, 0x00, 0xe0, 0xd1, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x03, 0xff, 0xc0, 0x03, 0xfe, 0x07, 0xff, 0x8e, 0x00, 0x02, 0x0e, 0x38, 0xe0, 0x78, 0x38, 0xe0, 0x83, 0xd0, 0xe3, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0xff, 0xff, 0xff, 0x03, 0x80, 0x00, 0x1c, 0x0e, 0x0d, 0xb1, 0x70, 0x38, 0x00, 0x01, 0xc0, 0xff, 0xfe, 0x07, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x1f, 0xff, 0xff, 0x00, 0x70, 0x00, 0x1c, 0x01, 0xc1, 0x84, 0x70, 0x3f, 0x11, 0x41, 0xc0, 0xe0, 0x18, 0x47, 0x03, 0x80, 0x00, 0x1c, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0xff, 0xfe, 0x00, 0x03, 0x84, 0x38, 0x00, 0x0e, 0x49, 0xe0, 0x00, 0x3c, 0x93, 0xf0, 0x00, 0xe0, 0x01, 0xc0, 0x03, 0x80, 0x07, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t cur_byte, bit, byte;

static uint8_t sokoban_next_bit(const uint8_t *input)
{
	uint8_t v = (cur_byte & 0x80) ? 1 : 0;

	cur_byte <<= 1;
	--bit;
	if(bit == 0)
	{
		bit = 7;
		++byte;
		cur_byte = pgm_read_byte(input + byte);
	}

	return v;
}

static uint8_t sokoban_next_3(const uint8_t *input)
{
	uint8_t v = sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	v <<= 1;
	v |= sokoban_next_bit(input);
	return v;
}

static void sokoban_load_level(uint8_t *level, const uint8_t *input)
{
	bit = 7;
	byte = 0;
	cur_byte = pgm_read_byte(input);

	for(uint8_t i = 0; i < LED_PIXELS; ++i)
	{
		level[i] = sokoban_next_3(input);
	}
}

static uint8_t sokoban_win(uint8_t *level)
{
	for(uint8_t y = 0; y < LED_HEIGHT; ++y)
	{
		for(uint8_t x = 0; x < LED_WIDTH; ++x)
		{
			if(field_get(level, x, y) == S_BOX)
			{
				return 0;
			}
		}
	}

	return 1;
}

static uint8_t sokoban_color(uint8_t color, uint8_t mask)
{
	return color & mask ? 0xFF : 0;
}

static void sokoban_draw(uint8_t *level)
{
	led_clear_black();
	for(uint8_t y = 0; y < LED_HEIGHT; ++y)
	{
		for(uint8_t x = 0; x < LED_WIDTH; ++x)
		{
			uint8_t color = field_get(level, x, y);
			led_set_color(sokoban_color(color, 0),
				sokoban_color(color, 1),
				sokoban_color(color, 2));

			led_set_pixel(x, y);
		}
	}

	led_update();
}

static uint8_t sokoban_move(uint8_t key)
{
	/*Position a = position_next(player, key);
	Position b = position_next(a, key);
	uint8_t at = field_get(level, a.x, a.y);

	switch(at)
	{
	case S_EMPTY:
	case S_GOAL:
		break;

	case S_BOX:
		{
			uint8_t bt = field_get(level, b.x, b.y);
			if(bt != S_EMPTY && bt != S_GOAL)
			{
				return 0;
			}

			field_set(level, a.x, a.y, S_EMPTY);
			field_set(level, b.x, b.y, bt == S_GOAL ? S_BOX_ON_GOAL : S_BOX);
		}
		break;

	case S_BOX_ON_GOAL:
		{
			uint8_t bt = field_get(level, b.x, b.y);
			if(bt != S_EMPTY && bt != S_GOAL)
			{
				return 0;
			}

			field_set(level, a.x, a.y, S_GOAL);
			field_set(level, b.x, b.y, bt == S_GOAL ? S_BOX_ON_GOAL : S_BOX);
		}
		break;

	default:
		return 0;
	}

	player = a;*/
	return 1;
}

static void sokoban(void)
{
	uint8_t level[LED_PIXELS];
	uint8_t cur_level = 0;
	uint8_t x = 0;
	uint8_t y = 0;

	sokoban_load_level(level, sokoban_levels);
	sokoban_draw(level);
	for(;;)
	{
		uint8_t key;
		while((key = key_get()))
		{
			switch(key)
			{
			case KEY_ESCAPE_PRESSED:
				return;

			case KEY_CENTER_PRESSED:

				break;

			case KEY_DOWN_PRESSED:

				break;

			case KEY_UP_PRESSED:

				break;

			case KEY_LEFT_PRESSED:

				break;

			case KEY_RIGHT_PRESSED:

				break;
			}
		}
	}
}
